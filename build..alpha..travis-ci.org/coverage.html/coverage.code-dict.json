{"/home/travis/build/npmtest/node-npmtest-editorconfig/test.js":"/* istanbul instrument in package npmtest_editorconfig */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-editorconfig/lib.npmtest_editorconfig.js":"/* istanbul instrument in package npmtest_editorconfig */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_editorconfig = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_editorconfig = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-editorconfig/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-editorconfig && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_editorconfig */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_editorconfig\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_editorconfig.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_editorconfig.rollup.js'] =\n            local.assetsDict['/assets.npmtest_editorconfig.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_editorconfig.__dirname + '/lib.npmtest_editorconfig.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-editorconfig/node_modules/editorconfig/editorconfig.js":"var os = require('os');\nvar path = require('path');\nvar fs = require('fs');\nvar util = require('util');\nvar Promise = require('bluebird');\nvar whenReadFile = Promise.promisify(fs.readFile);\n\nvar minimatch = require('./lib/fnmatch');\nvar iniparser = require('./lib/ini');\nvar Version = require('./lib/version');\nvar pkg = require('./package.json');\n\nvar knownProps = [\n  'end_of_line',\n  'indent_style',\n  'indent_size',\n  'insert_final_newline',\n  'trim_trailing_whitespace',\n  'charset'\n].reduce(function (set, prop) {\n  set[prop] = true;\n  return set;\n}, {});\n\nfunction fnmatch(filepath, glob) {\n  var matchOptions = {matchBase: true, dot: true, noext: true};\n  glob = glob.replace(/\\*\\*/g, '{*,**/**/**}');\n  return minimatch(filepath, glob, matchOptions);\n}\n\nfunction getConfigFileNames(filepath, options) {\n  var paths = [];\n  do {\n    filepath = path.dirname(filepath);\n    paths.push(path.join(filepath, options.config));\n  } while (filepath !== options.root);\n  return paths;\n}\n\nfunction getFilepathRoot(filepath) {\n  if (path.parse !== undefined) {\n    // Node.js >= 0.11.15\n    return path.parse(filepath).root;\n  }\n  if (os.platform() === 'win32') {\n    return path.resolve(filepath).match(/^(\\\\\\\\[^\\\\]+\\\\)?[^\\\\]+\\\\/)[0];\n  }\n  return '/';\n}\n\nfunction processMatches(matches, version) {\n  // Set indent_size to \"tab\" if indent_size is unspecified and\n  // indent_style is set to \"tab\".\n  if (\"indent_style\" in matches && matches.indent_style === \"tab\" &&\n    !(\"indent_size\" in matches) && version.gte(new Version(0, 10))) {\n    matches.indent_size = \"tab\";\n  }\n\n  // Set tab_width to indent_size if indent_size is specified and\n  // tab_width is unspecified\n  if (\"indent_size\" in matches && !(\"tab_width\" in matches) &&\n  matches.indent_size !== \"tab\")\n    matches.tab_width = matches.indent_size;\n\n  // Set indent_size to tab_width if indent_size is \"tab\"\n  if(\"indent_size\" in matches && \"tab_width\" in matches &&\n  matches.indent_size === \"tab\")\n    matches.indent_size = matches.tab_width;\n\n  return matches;\n}\n\nfunction processOptions(options, filepath) {\n  options = options || {};\n  return {\n    config: options.config || '.editorconfig',\n    version: new Version(options.version || pkg.version),\n    root: path.resolve(options.root || getFilepathRoot(filepath))\n  };\n}\n\nfunction buildFullGlob(pathPrefix, glob) {\n  switch (glob.indexOf('/')) {\n    case -1: glob = \"**/\" + glob; break;\n    case  0: glob = glob.substring(1); break;\n  }\n  return path.join(pathPrefix, glob);\n}\n\nfunction extendProps(props, options) {\n  for (var key in options) {\n    var value = options[key];\n    key = key.toLowerCase();\n    if (knownProps[key]) {\n      value = value.toLowerCase();\n    }\n    try {\n      value = JSON.parse(value);\n    } catch(e) {}\n    if (typeof value === 'undefined' || value === null) {\n      // null and undefined are values specific to JSON (no special meaning\n      // in editorconfig) & should just be returned as regular strings.\n      value = String(value);\n    }\n    props[key] = value;\n  }\n  return props;\n}\n\nfunction parseFromFiles(filepath, files, options) {\n  return getConfigsForFiles(files).then(function (configs) {\n    return configs.reverse();\n  }).reduce(function (matches, file) {\n    var pathPrefix = path.dirname(file.name);\n    file.contents.forEach(function (section) {\n      var glob = section[0], options = section[1];\n      if (!glob) return;\n      var fullGlob = buildFullGlob(pathPrefix, glob);\n      if (!fnmatch(filepath, fullGlob)) return;\n      matches = extendProps(matches, options);\n    });\n    return matches;\n  }, {}).then(function (matches) {\n    return processMatches(matches, options.version);\n  });\n}\n\nfunction parseFromFilesSync(filepath, files, options) {\n  var configs = getConfigsForFilesSync(files);\n  configs.reverse();\n  var matches = {};\n  configs.forEach(function(config) {\n    var pathPrefix = path.dirname(config.name);\n    config.contents.forEach(function(section) {\n      var glob = section[0], options = section[1];\n      if (!glob) return;\n      var fullGlob = buildFullGlob(pathPrefix, glob);\n      if (!fnmatch(filepath, fullGlob)) return;\n      matches = extendProps(matches, options);\n    });\n  });\n  return processMatches(matches, options.version);\n}\n\nfunction StopReduce(array) {\n  this.array = array;\n}\n\nStopReduce.prototype = Object.create(Error.prototype);\n\nfunction getConfigsForFiles(files) {\n  return Promise.reduce(files, function (configs, file) {\n    var contents = iniparser.parseString(file.contents);\n    configs.push({\n      name: file.name,\n      contents: contents\n    });\n    if ((contents[0][1].root || '').toLowerCase() === 'true') {\n      return Promise.reject(new StopReduce(configs));\n    }\n    return configs;\n  }, []).catch(StopReduce, function (stop) {\n    return stop.array;\n  });\n}\n\nfunction getConfigsForFilesSync(files) {\n  var configs = [];\n  for (var i in files) {\n    var file = files[i];\n    var contents = iniparser.parseString(file.contents);\n    configs.push({\n      name: file.name,\n      contents: contents\n    });\n    if ((contents[0][1].root || '').toLowerCase() === 'true') {\n      break;\n    }\n  };\n  return configs;\n}\n\nfunction readConfigFiles(filepaths) {\n  return Promise.map(filepaths, function (path) {\n    return whenReadFile(path, 'utf-8').catch(function () {\n      return '';\n    }).then(function (contents) {\n      return {name: path, contents: contents};\n    });\n  });\n}\n\nfunction readConfigFilesSync(filepaths) {\n  var files = [];\n  var file;\n  filepaths.forEach(function(filepath) {\n    try {\n      file = fs.readFileSync(filepath, 'utf8');\n    } catch (e) {\n      file = '';\n    }\n    files.push({name: filepath, contents: file});\n  });\n  return files;\n}\n\nmodule.exports.parseFromFiles = function (filepath, files, options) {\n  return new Promise (function (resolve, reject) {\n    filepath = path.resolve(filepath);\n    options = processOptions(options, filepath);\n    resolve(parseFromFiles(filepath, files, options));\n  });\n};\n\nmodule.exports.parseFromFilesSync = function (filepath, files, options) {\n  filepath = path.resolve(filepath);\n  options = processOptions(options, filepath);\n  return parseFromFilesSync(filepath, files, options);\n};\n\nmodule.exports.parse = function (filepath, options) {\n  return new Promise (function (resolve, reject) {\n    filepath = path.resolve(filepath);\n    options = processOptions(options, filepath);\n    var filepaths = getConfigFileNames(filepath, options);\n    var files = readConfigFiles(filepaths);\n    resolve(parseFromFiles(filepath, files, options));\n  });\n};\n\nmodule.exports.parseSync = function (filepath, options) {\n    filepath = path.resolve(filepath);\n    options = processOptions(options, filepath);\n    var filepaths = getConfigFileNames(filepath, options);\n    var files = readConfigFilesSync(filepaths);\n    return parseFromFilesSync(filepath, files, options);\n};\n","/home/travis/build/npmtest/node-npmtest-editorconfig/node_modules/editorconfig/lib/fnmatch.js":"// Based on minimatch.js by isaacs <https://npmjs.org/package/minimatch>\n\n;(function (require, exports, module, platform) {\n\n  if (module) module.exports = minimatch\n  else exports.minimatch = minimatch\n\n  if (!require) {\n    require = function (id) {\n      switch (id) {\n        case \"sigmund\": return function sigmund (obj) {\n            return JSON.stringify(obj)\n          }\n        case \"path\": return { basename: function (f) {\n              f = f.split(/[\\/\\\\]/)\n              var e = f.pop()\n              if (!e) e = f.pop()\n              return e\n            }}\n        case \"lru-cache\": return function LRUCache () {\n            // not quite an LRU, but still space-limited.\n            var cache = {}\n            var cnt = 0\n            this.set = function (k, v) {\n              cnt ++\n              if (cnt >= 100) cache = {}\n              cache[k] = v\n            }\n            this.get = function (k) { return cache[k] }\n          }\n      }\n    }\n  }\n\n  minimatch.Minimatch = Minimatch\n\n  var LRU = require(\"lru-cache\")\n    , cache = minimatch.cache = new LRU({max: 100})\n    , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\n    , sigmund = require(\"sigmund\")\n\n  var path = require(\"path\")\n    // any single thing other than /\n    // don't need to escape / when using new RegExp()\n    , qmark = \"[^/]\"\n\n    // * => any number of characters\n    , star = qmark + \"*?\"\n\n    // ** when dots are allowed.  Anything goes, except .. and .\n    // not (^ or / followed by one or two dots followed by $ or /),\n    // followed by anything, any number of times.\n    , twoStarDot = \"(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?\"\n\n    // not a ^ or / followed by a dot,\n    // followed by anything, any number of times.\n    , twoStarNoDot = \"(?:(?!(?:\\\\\\/|^)\\\\.).)*?\"\n\n    // characters that need to be escaped in RegExp.\n    , reSpecials = charSet(\"().*{}+?[]^$\\\\!\")\n\n// \"abc\" -> { a:true, b:true, c:true }\n  function charSet (s) {\n    return s.split(\"\").reduce(function (set, c) {\n      set[c] = true\n      return set\n    }, {})\n  }\n\n// normalizes slashes.\n  var slashSplit = /\\/+/\n\n  minimatch.monkeyPatch = monkeyPatch\n  function monkeyPatch () {\n    var desc = Object.getOwnPropertyDescriptor(String.prototype, \"match\")\n    var orig = desc.value\n    desc.value = function (p) {\n      if (p instanceof Minimatch) return p.match(this)\n      return orig.call(this, p)\n    }\n    Object.defineProperty(String.prototype, desc)\n  }\n\n  minimatch.filter = filter\n  function filter (pattern, options) {\n    options = options || {}\n    return function (p, i, list) {\n      return minimatch(p, pattern, options)\n    }\n  }\n\n  function ext (a, b) {\n    a = a || {}\n    b = b || {}\n    var t = {}\n    Object.keys(b).forEach(function (k) {\n      t[k] = b[k]\n    })\n    Object.keys(a).forEach(function (k) {\n      t[k] = a[k]\n    })\n    return t\n  }\n\n  minimatch.defaults = function (def) {\n    if (!def || !Object.keys(def).length) return minimatch\n\n    var orig = minimatch\n\n    var m = function minimatch (p, pattern, options) {\n      return orig.minimatch(p, pattern, ext(def, options))\n    }\n\n    m.Minimatch = function Minimatch (pattern, options) {\n      return new orig.Minimatch(pattern, ext(def, options))\n    }\n\n    return m\n  }\n\n  Minimatch.defaults = function (def) {\n    if (!def || !Object.keys(def).length) return Minimatch\n    return minimatch.defaults(def).Minimatch\n  }\n\n\n  function minimatch (p, pattern, options) {\n    if (typeof pattern !== \"string\") {\n      throw new TypeError(\"glob pattern string required\")\n    }\n\n    if (!options) options = {}\n\n        // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n      return false\n    }\n\n    // \"\" only matches \"\"\n    if (pattern.trim() === \"\") return p === \"\"\n\n    return new Minimatch(pattern, options).match(p)\n  }\n\n  function Minimatch (pattern, options) {\n    if (!(this instanceof Minimatch)) {\n      return new Minimatch(pattern, options, cache)\n    }\n\n    if (typeof pattern !== \"string\") {\n      throw new TypeError(\"glob pattern string required\")\n    }\n\n    if (!options) options = {}\n\n        // windows: need to use /, not \\\n        // On other platforms, \\ is a valid (albeit bad) filename char.\n    if (platform === \"win32\") {\n      pattern = pattern.split(\"\\\\\").join(\"/\")\n    }\n\n    // lru storage.\n    // these things aren't particularly big, but walking down the string\n    // and turning it into a regexp can get pretty costly.\n    var cacheKey = pattern + \"\\n\" + sigmund(options)\n    var cached = minimatch.cache.get(cacheKey)\n    if (cached) return cached\n    minimatch.cache.set(cacheKey, this)\n\n    this.options = options\n    this.set = []\n    this.pattern = pattern\n    this.regexp = null\n    this.negate = false\n    this.comment = false\n    this.empty = false\n\n      // make the set of regexps etc.\n    this.make()\n  }\n\n  Minimatch.prototype.make = make\n  function make () {\n    // don't do it more than once.\n    if (this._made) return\n\n    var pattern = this.pattern\n    var options = this.options\n\n      // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n      this.comment = true\n      return\n    }\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n      // step 2: expand braces\n    var set = this.globSet = this.braceExpand()\n\n    if (options.debug) console.error(this.pattern, set)\n\n        // step 3: now we have a set, so turn each one into a series of path-portion\n        // matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n    set = this.globParts = set.map(function (s) {\n        return s.split(slashSplit)\n      })\n\n    if (options.debug) console.error(this.pattern, set)\n\n        // glob --> regexps\n    set = set.map(function (s, si, set) {\n      return s.map(this.parse, this)\n    }, this)\n\n    if (options.debug) console.error(this.pattern, set)\n\n        // filter out everything that didn't compile properly.\n    set = set.filter(function (s) {\n      return -1 === s.indexOf(false)\n    })\n\n    if (options.debug) console.error(this.pattern, set)\n\n    this.set = set\n  }\n\n  Minimatch.prototype.parseNegate = parseNegate\n  function parseNegate () {\n    var pattern = this.pattern\n      , negate = false\n      , options = this.options\n      , negateOffset = 0\n\n    if (options.nonegate) return\n\n    for ( var i = 0, l = pattern.length\n      ; i < l && pattern.charAt(i) === \"!\"\n      ; i ++) {\n      negate = !negate\n      negateOffset ++\n    }\n\n    if (negateOffset) this.pattern = pattern.substr(negateOffset)\n    this.negate = negate\n  }\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\n  minimatch.braceExpand = function (pattern, options) {\n    return new Minimatch(pattern, options).braceExpand()\n  }\n\n  Minimatch.prototype.braceExpand = braceExpand\n  function braceExpand (pattern, options) {\n    options = options || this.options\n    pattern = typeof pattern === \"undefined\"\n        ? this.pattern : pattern\n\n    if (typeof pattern === \"undefined\") {\n      throw new Error(\"undefined pattern\")\n    }\n\n    if (options.nobrace ||\n      !pattern.match(/\\{.*\\}/)) {\n      // shortcut. no need to expand.\n      return [pattern]\n    }\n\n    var escaping = false\n\n      // examples and comments refer to this crazy pattern:\n      // a{b,c{d,e},{f,g}h}x{y,z}\n      // expected:\n      // abxy\n      // abxz\n      // acdxy\n      // acdxz\n      // acexy\n      // acexz\n      // afhxy\n      // afhxz\n      // aghxy\n      // aghxz\n\n      // everything before the first \\{ is just a prefix.\n      // So, we pluck that off, and work with the rest,\n      // and then prepend it to everything we find.\n    if (pattern.charAt(0) !== \"{\") {\n      // console.error(pattern)\n      var prefix = null\n      for (var i = 0, l = pattern.length; i < l; i ++) {\n        var c = pattern.charAt(i)\n          // console.error(i, c)\n        if (c === \"\\\\\") {\n          escaping = !escaping\n        } else if (c === \"{\" && !escaping) {\n          prefix = pattern.substr(0, i)\n          break\n        }\n      }\n\n      // actually no sets, all { were escaped.\n      if (prefix === null) {\n        // console.error(\"no sets\")\n        return [pattern]\n      }\n\n      var tail = braceExpand(pattern.substr(i), options)\n      return tail.map(function (t) {\n        return prefix + t\n      })\n    }\n\n    // now we have something like:\n    // {b,c{d,e},{f,g}h}x{y,z}\n    // walk through the set, expanding each part, until\n    // the set ends.  then, we'll expand the suffix.\n    // If the set only has a single member, then'll put the {} back\n\n    // first, handle numeric sets, since they're easier\n    var numset = pattern.match(/^\\{(-?[0-9]+)\\.\\.(-?[0-9]+)\\}/)\n    if (numset) {\n      // console.error(\"numset\", numset[1], numset[2])\n      var suf = braceExpand(pattern.substr(numset[0].length), options)\n        , start = +numset[1]\n        , end = +numset[2]\n        , inc = start > end ? -1 : 1\n        , set = []\n      for (var i = start; i != (end + inc); i += inc) {\n        // append all the suffixes\n        for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\n          set.push(i + suf[ii])\n        }\n      }\n      return set\n    }\n\n    // ok, walk through the set\n    // We hope, somewhat optimistically, that there\n    // will be a } at the end.\n    // If the closing brace isn't found, then the pattern is\n    // interpreted as braceExpand(\"\\\\\" + pattern) so that\n    // the leading \\{ will be interpreted literally.\n    var i = 1 // skip the \\{\n      , depth = 1\n      , set = []\n      , member = \"\"\n      , sawEnd = false\n      , escaping = false\n\n    function addMember () {\n      set.push(member)\n      member = \"\"\n    }\n\n    // console.error(\"Entering for\")\n    FOR: for (i = 1, l = pattern.length; i < l; i ++) {\n        var c = pattern.charAt(i)\n          // console.error(\"\", i, c)\n\n        if (escaping) {\n          escaping = false\n          member += \"\\\\\" + c\n        } else {\n          switch (c) {\n            case \"\\\\\":\n              escaping = true\n              continue\n\n            case \"{\":\n              depth ++\n              member += \"{\"\n              continue\n\n            case \"}\":\n              depth --\n                // if this closes the actual set, then we're done\n              if (depth === 0) {\n                addMember()\n                  // pluck off the close-brace\n                i ++\n                break FOR\n              } else {\n                member += c\n                continue\n              }\n\n            case \",\":\n              if (depth === 1) {\n                addMember()\n              } else {\n                member += c\n              }\n              continue\n\n            default:\n              member += c\n              continue\n          } // switch\n        } // else\n      } // for\n\n    // now we've either finished the set, and the suffix is\n    // pattern.substr(i), or we have *not* closed the set,\n    // and need to escape the leading brace\n    if (depth !== 0) {\n      // console.error(\"didn't close\", pattern)\n      return braceExpand(\"\\\\\" + pattern, options)\n    }\n\n    // x{y,z} -> [\"xy\", \"xz\"]\n    // console.error(\"set\", set)\n    // console.error(\"suffix\", pattern.substr(i))\n    var suf = braceExpand(pattern.substr(i), options)\n      // [\"b\", \"c{d,e}\",\"{f,g}h\"] ->\n      //   [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]]\n    var addBraces = set.length === 1\n      // console.error(\"set pre-expanded\", set)\n    set = set.map(function (p) {\n      return braceExpand(p, options)\n    })\n      // console.error(\"set expanded\", set)\n\n\n      // [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]] ->\n      //   [\"b\", \"cd\", \"ce\", \"fh\", \"gh\"]\n    set = set.reduce(function (l, r) {\n      return l.concat(r)\n    })\n\n    if (addBraces) {\n      set = set.map(function (s) {\n        return \"{\" + s + \"}\"\n      })\n    }\n\n    // now attach the suffixes.\n    var ret = []\n    for (var i = 0, l = set.length; i < l; i ++) {\n      for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\n        ret.push(set[i] + suf[ii])\n      }\n    }\n    return ret\n  }\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n  Minimatch.prototype.parse = parse\n  var SUBPARSE = {}\n  function parse (pattern, isSub) {\n    var options = this.options\n\n      // shortcuts\n    if (!options.noglobstar && pattern === \"**\") return GLOBSTAR\n    if (pattern === \"\") return \"\"\n\n    var re = \"\"\n      , hasMagic = !!options.nocase\n      , escaping = false\n      // ? => one single character\n      , patternListStack = []\n      , plType\n      , stateChar\n      , inClass = false\n      , reClassStart = -1\n      , classStart = -1\n      // . and .. never match anything that doesn't start with .,\n      // even when options.dot is set.\n      , patternStart = pattern.charAt(0) === \".\" ? \"\" // anything\n        // not (start or / followed by . or .. followed by / or end)\n        : options.dot ? \"(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))\"\n          : \"(?!\\\\.)\"\n\n    function clearStateChar () {\n      if (stateChar) {\n        // we had some state-tracking character\n        // that wasn't consumed by this pass.\n        switch (stateChar) {\n          case \"*\":\n            re += star\n            hasMagic = true\n            break\n          case \"?\":\n            re += qmark\n            hasMagic = true\n            break\n          default:\n            re += \"\\\\\"+stateChar\n            break\n        }\n        stateChar = false\n      }\n    }\n\n    for ( var i = 0, len = pattern.length, c\n      ; (i < len) && (c = pattern.charAt(i))\n      ; i ++ ) {\n\n      if (options.debug) {\n        console.error(\"%s\\t%s %s %j\", pattern, i, re, c)\n      }\n\n      // skip over any that are escaped.\n      if (escaping && reSpecials[c]) {\n        re += \"\\\\\" + c\n        escaping = false\n        continue\n      }\n\n      SWITCH: switch (c) {\n          case \"/\":\n            // completely not allowed, even escaped.\n            // Should already be path-split by now.\n            return false\n\n          case \"\\\\\":\n            clearStateChar()\n            escaping = true\n            continue\n\n          // the various stateChar values\n          // for the \"extglob\" stuff.\n          case \"?\":\n          case \"*\":\n          case \"+\":\n          case \"@\":\n          case \"!\":\n            if (options.debug) {\n              console.error(\"%s\\t%s %s %j <-- stateChar\", pattern, i, re, c)\n            }\n\n            // all of those are literals inside a class, except that\n            // the glob [!a] means [^a] in regexp\n            if (inClass) {\n              if (c === \"!\" && i === classStart + 1) c = \"^\"\n              re += c\n              continue\n            }\n\n            // if we already have a stateChar, then it means\n            // that there was something like ** or +? in there.\n            // Handle the stateChar, then proceed with this one.\n            clearStateChar()\n            stateChar = c\n              // if extglob is disabled, then +(asdf|foo) isn't a thing.\n              // just clear the statechar *now*, rather than even diving into\n              // the patternList stuff.\n            if (options.noext) clearStateChar()\n            continue\n\n          case \"(\":\n            if (inClass) {\n              re += \"(\"\n              continue\n            }\n\n            if (!stateChar) {\n              re += \"\\\\(\"\n              continue\n            }\n\n            plType = stateChar\n            patternListStack.push({ type: plType\n              , start: i - 1\n              , reStart: re.length })\n              // negation is (?:(?!js)[^/]*)\n            re += stateChar === \"!\" ? \"(?:(?!\" : \"(?:\"\n            stateChar = false\n            continue\n\n          case \")\":\n            if (inClass || !patternListStack.length) {\n              re += \"\\\\)\"\n              continue\n            }\n\n            hasMagic = true\n            re += \")\"\n            plType = patternListStack.pop().type\n              // negation is (?:(?!js)[^/]*)\n              // The others are (?:<pattern>)<type>\n            switch (plType) {\n              case \"!\":\n                re += \"[^/]*?)\"\n                break\n              case \"?\":\n              case \"+\":\n              case \"*\": re += plType\n              case \"@\": break // the default anyway\n            }\n            continue\n\n          case \"|\":\n            if (inClass || !patternListStack.length || escaping) {\n              re += \"\\\\|\"\n              escaping = false\n              continue\n            }\n\n            re += \"|\"\n            continue\n\n          // these are mostly the same in regexp and glob\n          case \"[\":\n            // swallow any state-tracking char before the [\n            clearStateChar()\n\n            if (inClass) {\n              re += \"\\\\\" + c\n              continue\n            }\n\n            inClass = true\n            classStart = i\n            reClassStart = re.length\n            re += c\n            continue\n\n          case \"]\":\n            //  a right bracket shall lose its special\n            //  meaning and represent itself in\n            //  a bracket expression if it occurs\n            //  first in the list.  -- POSIX.2 2.8.3.2\n            if (i === classStart + 1 || !inClass) {\n              re += \"\\\\\" + c\n              escaping = false\n              continue\n            }\n\n            // finish up the class.\n            hasMagic = true\n            inClass = false\n            re += c\n            continue\n\n          default:\n            // swallow any state char that wasn't consumed\n            clearStateChar()\n\n            if (escaping) {\n              // no need\n              escaping = false\n            } else if (reSpecials[c]\n              && !(c === \"^\" && inClass)) {\n              re += \"\\\\\"\n            }\n\n            re += c\n\n        } // switch\n    } // for\n\n\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n    if (inClass) {\n      // split where the last [ was, and escape it\n      // this is a huge pita.  We now have to re-walk\n      // the contents of the would-be class to re-translate\n      // any characters that were passed through as-is\n      var cs = pattern.substr(classStart + 1)\n        , sp = this.parse(cs, SUBPARSE)\n      re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0]\n      hasMagic = hasMagic || sp[1]\n    }\n\n    // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n    var pl\n    while (pl = patternListStack.pop()) {\n      var tail = re.slice(pl.reStart + 3)\n        // maybe some even number of \\, then maybe 1 \\, followed by a |\n      tail = tail.replace(/((?:\\\\{2})*)(\\\\?)\\|/g, function (_, $1, $2) {\n        if (!$2) {\n          // the | isn't already escaped, so escape it.\n          $2 = \"\\\\\"\n        }\n\n        // need to escape all those slashes *again*, without escaping the\n        // one that we need for escaping the | character.  As it works out,\n        // escaping an even number of slashes can be done by simply repeating\n        // it exactly after itself.  That's why this trick works.\n        //\n        // I am sorry that you have to see this.\n        return $1 + $1 + $2 + \"|\"\n      })\n\n        // console.error(\"tail=%j\\n   %s\", tail, tail)\n      var t = pl.type === \"*\" ? star\n          : pl.type === \"?\" ? qmark\n            : \"\\\\\" + pl.type\n\n      hasMagic = true\n      re = re.slice(0, pl.reStart)\n        + t + \"\\\\(\"\n        + tail\n    }\n\n    // handle trailing things that only matter at the very end.\n    clearStateChar()\n    if (escaping) {\n      // trailing \\\\\n      re += \"\\\\\\\\\"\n    }\n\n    // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n    var addPatternStart = false\n    switch (re.charAt(0)) {\n      case \".\":\n      case \"[\":\n      case \"(\": addPatternStart = true\n    }\n\n    // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n    if (re !== \"\" && hasMagic) re = \"(?=.)\" + re\n\n    if (addPatternStart) re = patternStart + re\n\n        // parsing just a piece of a larger pattern.\n    if (isSub === SUBPARSE) {\n      return [ re, hasMagic ]\n    }\n\n    // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n    if (!hasMagic) {\n      return globUnescape(pattern)\n    }\n\n    var flags = options.nocase ? \"i\" : \"\"\n      , regExp = new RegExp(\"^\" + re + \"$\", flags)\n\n    regExp._glob = pattern\n    regExp._src = re\n\n    return regExp\n  }\n\n  minimatch.makeRe = function (pattern, options) {\n    return new Minimatch(pattern, options || {}).makeRe()\n  }\n\n  Minimatch.prototype.makeRe = makeRe\n  function makeRe () {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n    var set = this.set\n\n    if (!set.length) return this.regexp = false\n    var options = this.options\n\n    var twoStar = options.noglobstar ? star\n        : options.dot ? twoStarDot\n          : twoStarNoDot\n      , flags = options.nocase ? \"i\" : \"\"\n\n    var re = set.map(function (pattern) {\n      return pattern.map(function (p) {\n        return (p === GLOBSTAR) ? twoStar\n            : (typeof p === \"string\") ? regExpEscape(p)\n              : p._src\n      }).join(\"\\\\\\/\")\n    }).join(\"|\")\n\n      // must match entire pattern\n      // ending in a * or ** will make it less strict.\n    re = \"^(?:\" + re + \")$\"\n\n      // can match anything, as long as it's not this.\n    if (this.negate) re = \"^(?!\" + re + \").*$\"\n\n    try {\n      return this.regexp = new RegExp(re, flags)\n    } catch (ex) {\n        return this.regexp = false\n      }\n  }\n\n  minimatch.match = function (list, pattern, options) {\n    var mm = new Minimatch(pattern, options)\n    list = list.filter(function (f) {\n      return mm.match(f)\n    })\n    if (options.nonull && !list.length) {\n      list.push(pattern)\n    }\n    return list\n  }\n\n  Minimatch.prototype.match = match\n  function match (f, partial) {\n    // console.error(\"match\", f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) return false\n    if (this.empty) return f === \"\"\n\n    if (f === \"/\" && partial) return true\n\n    var options = this.options\n\n      // windows: need to use /, not \\\n      // On other platforms, \\ is a valid (albeit bad) filename char.\n    if (platform === \"win32\") {\n      f = f.split(\"\\\\\").join(\"/\")\n    }\n\n    // treat the test path as a set of pathparts.\n    f = f.split(slashSplit)\n    if (options.debug) {\n      console.error(this.pattern, \"split\", f)\n    }\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    var set = this.set\n      // console.error(this.pattern, \"set\", set)\n\n    for (var i = 0, l = set.length; i < l; i ++) {\n      var pattern = set[i]\n      var hit = this.matchOne(f, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) return true\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) return false\n    return this.negate\n  }\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\n  Minimatch.prototype.matchOne = function (file, pattern, partial) {\n    var options = this.options\n\n    if (options.debug) {\n      console.error(\"matchOne\",\n      { \"this\": this\n        , file: file\n        , pattern: pattern })\n    }\n\n    if (options.matchBase && pattern.length === 1) {\n      file = path.basename(file.join(\"/\")).split(\"/\")\n    }\n\n    if (options.debug) {\n      console.error(\"matchOne\", file.length, pattern.length)\n    }\n\n    for ( var fi = 0\n        , pi = 0\n        , fl = file.length\n        , pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi ++, pi ++ ) {\n\n      if (options.debug) {\n        console.error(\"matchOne loop\")\n      }\n      var p = pattern[pi]\n        , f = file[fi]\n\n      if (options.debug) {\n        console.error(pattern, p, f)\n      }\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      if (p === false) return false\n\n      if (p === GLOBSTAR) {\n        if (options.debug)\n          console.error('GLOBSTAR', [pattern, p, f])\n\n            // \"**\"\n            // a/**/b/**/c would match the following:\n            // a/b/x/y/z/c\n            // a/x/y/z/b/c\n            // a/b/x/b/x/c\n            // a/b/c\n            // To do this, take the rest of the pattern after\n            // the **, and see if it would match the file remainder.\n            // If so, return success.\n            // If not, the ** \"swallows\" a segment, and try again.\n            // This is recursively awful.\n            //\n            // a/**/b/**/c matching a/b/x/y/z/c\n            // - a matches a\n            // - doublestar\n            //   - matchOne(b/x/y/z/c, b/**/c)\n            //     - b matches b\n            //     - doublestar\n            //       - matchOne(x/y/z/c, c) -> no\n            //       - matchOne(y/z/c, c) -> no\n            //       - matchOne(z/c, c) -> no\n            //       - matchOne(c, c) yes, hit\n        var fr = fi\n          , pr = pi + 1\n        if (pr === pl) {\n          if (options.debug)\n            console.error('** at the end')\n              // a ** at the end will just swallow the rest.\n              // We have found a match.\n              // however, it will not swallow /.x, unless\n              // options.dot is set.\n              // . and .. are *never* matched by **, for explosively\n              // exponential reasons.\n          for ( ; fi < fl; fi ++) {\n            if (file[fi] === \".\" || file[fi] === \"..\" ||\n            (!options.dot && file[fi].charAt(0) === \".\")) return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        WHILE: while (fr < fl) {\n            var swallowee = file[fr]\n\n            if (options.debug) {\n              console.error('\\nglobstar while',\n                file, fr, pattern, pr, swallowee)\n            }\n\n            // XXX remove this slice.  Just pass the start index.\n            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n              if (options.debug)\n                console.error('globstar found match!', fr, fl, swallowee)\n                  // found a match.\n              return true\n            } else {\n              // can't swallow \".\" or \"..\" ever.\n              // can only swallow \".foo\" when explicitly asked.\n              if (swallowee === \".\" || swallowee === \"..\" ||\n              (!options.dot && swallowee.charAt(0) === \".\")) {\n                if (options.debug)\n                  console.error(\"dot detected!\", file, fr, pattern, pr)\n                break WHILE\n              }\n\n              // ** swallows a segment, and continue.\n              if (options.debug)\n                console.error('globstar swallow a segment, and continue')\n              fr ++\n            }\n          }\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        // If there's more *pattern* left, then\n        if (partial) {\n          // ran out of file\n          // console.error(\"\\n>>> no match, partial?\", file, fr, pattern, pr)\n          if (fr === fl) return true\n        }\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      var hit\n      if (typeof p === \"string\") {\n        if (options.nocase) {\n          hit = f.toLowerCase() === p.toLowerCase()\n        } else {\n          hit = f === p\n        }\n        if (options.debug) {\n          console.error(\"string match\", p, f, hit)\n        }\n      } else {\n        hit = f.match(p)\n        if (options.debug) {\n          console.error(\"pattern match\", p, f, hit)\n        }\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      var emptyFileEnd = (fi === fl - 1) && (file[fi] === \"\")\n      return emptyFileEnd\n    }\n\n    // should be unreachable.\n    throw new Error(\"wtf?\")\n  }\n\n\n// replace stuff like \\* with *\n  function globUnescape (s) {\n    return s.replace(/\\\\(.)/g, \"$1\")\n  }\n\n\n  function regExpEscape (s) {\n    return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\")\n  }\n\n})( typeof require === \"function\" ? require : null,\n  this,\n    typeof module === \"object\" ? module : null,\n    typeof process === \"object\" ? process.platform : \"win32\"\n)\n","/home/travis/build/npmtest/node-npmtest-editorconfig/node_modules/editorconfig/lib/ini.js":"// Based on iniparser by shockie <https://npmjs.org/package/iniparser>\n\n/*\n * get the file handler\n */\nvar fs = require('fs');\n\n/*\n * define the possible values:\n * section: [section]\n * param: key=value\n * comment: ;this is a comment\n */\nvar regex = {\n  section: /^\\s*\\[(([^#;]|\\\\#|\\\\;)+)\\]\\s*([#;].*)?$/,\n  param: /^\\s*([\\w\\.\\-\\_]+)\\s*[=:]\\s*(.*?)\\s*([#;].*)?$/,\n  comment: /^\\s*[#;].*$/\n};\n\n/*\n * parses a .ini file\n * @param: {String} file, the location of the .ini file\n * @param: {Function} callback, the function that will be called when parsing is done\n * @return: none\n */\nmodule.exports.parse = function (file, callback) {\n  if (!callback) {\n    return;\n  }\n  fs.readFile(file, 'utf8', function (err, data) {\n    if (err) {\n      callback(err);\n    } else {\n      callback(null, parse(data));\n    }\n  });\n};\n\nmodule.exports.parseSync = function (file) {\n  return parse(fs.readFileSync(file, 'utf8'));\n};\n\nfunction parse (data) {\n  var sectionBody = {};\n  var sectionName = null;\n  var value = [[sectionName, sectionBody]];\n  var lines = data.split(/\\r\\n|\\r|\\n/);\n  lines.forEach(function (line) {\n    var match;\n    if (regex.comment.test(line)) {\n      return;\n    } else if (regex.param.test(line)) {\n      match = line.match(regex.param);\n      sectionBody[match[1]] = match[2];\n    } else if (regex.section.test(line)) {\n      match = line.match(regex.section);\n      sectionName = match[1];\n      sectionBody = {};\n      value.push([sectionName, sectionBody]);\n    }\n  });\n  return value;\n}\n\nmodule.exports.parseString = parse;\n","/home/travis/build/npmtest/node-npmtest-editorconfig/node_modules/editorconfig/lib/version.js":"function Version(version) {\n  var args = arguments;\n  this.components = typeof version === \"string\" ?\n    version.split(\".\").map(function(x){return parseInt(x, 10);}) :\n    Object.keys(arguments).map(function(k){return args[k];});\n\n  var len = this.components.length;\n  this.major = len ? this.components[0] : 0;\n  this.minor = len > 1 ? this.components[1] : 0;\n  this.build = len > 2 ? this.components[2] : 0;\n  this.revision = len > 3 ? this.components[3] : 0;\n\n  if (typeof version !== \"string\") {\n    return;\n  }\n\n  var ext = version.split(\"-\");\n  if (ext.length === 2) {\n    this.configuration = ext[1];\n  }\n}\n\nVersion.prototype = {\n  toString: function() {\n    var version = this.components.join(\".\");\n    if (typeof this.configuration !== \"undefined\") {\n      version += \"-\" + this.configuration;\n    }\n    return version;\n  },\n  gte: function(other){\n    if (this.major < other.major) {\n      return false;\n    }\n    if (this.minor < other.minor) {\n      return false;\n    }\n    if (this.build < other.build) {\n      return false;\n    }\n    if (this.revision < other.revision) {\n      return false;\n    }\n    return true;\n  }\n};\n\nmodule.exports = Version;\n"}